# EventPay Manager - AI開発ルール

## 基本方針

### AI協調開発の目標
- **効率性**: 複数AIの特性を活かした最適な役割分担
- **品質**: 人間の監督下でのAI協調による高品質なコード生成
- **安全性**: セキュリティリスクを最小限に抑えた開発プロセス
- **継続性**: 持続可能で拡張可能なAI開発体制の構築

### 開発体制
- **主要AI**: Claude Code（メイン開発、統括管理）
- **協調AI**: zen-mcp-server経由の複数AI（専門的タスク）
- **人間監督**: 最終チェック、重要な意思決定、セキュリティ検証

## AI協調ワークフロー

### 1. タスク分析・AI選択
```markdown
**Claude Code の役割**:
- 要件分析とタスク分解
- 適切なAIの選択と割り当て
- 全体的な進行管理と品質統制

**zen-mcp-server AI の役割**:
- 専門性を活かした特定タスクの実行
- 深い分析・検証・最適化
- Claude Code への詳細フィードバック
```

### 自動zen-mcp-server使用条件

Claude Codeは以下の条件でzen-mcp-serverツールを**自動提案**または**必須実行**します：

#### 必須実行条件（MUST）
- **新機能実装開始時**: `/consensus`で設計合意形成
- **コミット前**: `/precommit`で最終品質チェック
- **セキュリティ関連コード**: `/secaudit`でセキュリティ監査
- **複雑なバグ報告**: `/debug`で根本原因分析

#### 強く推奨条件（SHOULD）
- **コードレビュー時**: `/codereview`で包括的レビュー
- **アーキテクチャ変更**: `/analyze`で影響分析
- **リファクタリング**: `/refactor`で改善提案
- **テスト作成**: `/testgen`でテストケース生成

#### 自動提案の実装
```markdown
各条件に該当する場合、Claude Codeは以下の形式で提案：

「この[タスク]では複数AIによる検証が有効です。
/[ツール名]で[具体的な分析内容]を実行しますか？」

ユーザーの承認後、適切なモデルを自動選択して実行
```

### 2. AI選択基準

#### コード分析・レビュー
- **Gemini Pro**: 深いセキュリティ分析、アーキテクチャレビュー
- **O3**: 論理的なコード検証、バグ発見
- **Gemini Flash**: 高速なスタイルチェック、簡単なレビュー

#### 設計・計画
- **O3**: 複雑なロジック設計、アルゴリズム最適化
- **Gemini Pro**: システム設計、アーキテクチャ検討
- **Claude Code**: 全体統括、要件整理

#### 実装・テスト
- **Claude Code**: メイン実装、ViewComponent作成
- **O3**: 複雑なビジネスロジック、テストケース設計
- **Gemini Flash**: 簡単な実装、ドキュメント作成

### 3. 情報共有・引き継ぎ

#### 会話スレッド管理
- zen-mcp-serverの会話スレッド機能を活用
- 最大10回の交換（設定で調整可能）
- 3時間の有効期限（設定で調整可能）
- コンテキスト保持でAI間のシームレスな連携

#### 進捗記録
```markdown
**必須記録項目**:
- 使用したAI（Claude Code, Gemini Pro, O3, Flash等）
- タスク内容と結果
- AI間の引き継ぎ内容
- 人間による確認・承認ポイント
```

## 品質保証・セキュリティ

### 1. コード品質チェック
```bash
# 人間による最終確認前に必須
docker-compose exec web bundle exec rspec
docker-compose exec web bundle exec rubocop
```

### 2. セキュリティ検証ポイント
- **認証・認可**: トークン生成、有効期限、権限チェック
- **入力検証**: バリデーション、SQLインジェクション対策
- **秘密情報**: 環境変数、ログ出力、コード内のハードコーディング
- **CSRF保護**: Rails標準機能の適切な使用

### 3. AI生成コードの検証プロセス
1. **AI実装**: Claude Code または協調AIによる初期実装
2. **相互検証**: 別AIによるコードレビュー（zen-mcp-server活用）
3. **自動テスト**: RSpec、RuboCopによる機械的チェック
4. **人間確認**: セキュリティ・ビジネスロジックの最終検証
5. **承認・マージ**: 人間による最終判断

### 4. 禁止事項
- **秘密情報の露出**: APIキー、パスワード、トークンのハードコーディング
- **セキュリティ機能の迂回**: CSRF保護、認証の無効化
- **テスト・品質チェックのスキップ**: 人間確認なしでの本番反映
- **無制限なAI使用**: コスト管理なしでの大量API呼び出し

## 技術仕様・制約

### 1. zen-mcp-server設定
```bash
# 基本設定場所
/home/bohemian1506/ai-development/zen-mcp-server/

# 重要ファイル
- CLAUDE.md: 開発ガイド
- docs/ai-collaboration.md: AI協調機能説明
- config.py: サーバー設定
```

### 2. API使用量管理
- **コスト上限**: 月間予算内での使用
- **優先度管理**: 重要タスクへのリソース優先配分
- **効率化**: 適切なAI選択によるコスト最適化

### 3. 各AIの特性・使い分け

#### Claude Code
- **得意**: Rails実装、ViewComponent、全体統括
- **使用場面**: メイン開発、最終調整、ユーザー対応

#### Gemini Pro
- **得意**: 深い分析、セキュリティ、アーキテクチャ
- **使用場面**: セキュリティレビュー、複雑な設計検討

#### O3
- **得意**: 論理的思考、数学的処理、バグ発見
- **使用場面**: アルゴリズム最適化、テストケース設計

#### Gemini Flash
- **得意**: 高速処理、簡単なタスク
- **使用場面**: スタイルチェック、ドキュメント作成

## ドキュメント管理

### 1. AI作業ログ記録
```markdown
**作業サマリーへの追加項目**:
- 使用したAI一覧
- AI間の会話・引き継ぎ内容
- 各AIの貢献度・成果
- 人間による介入・判断ポイント
```

### 2. 意思決定記録
- **重要な設計判断**: AIの提案と人間の最終決定
- **セキュリティ判断**: リスク評価と対策選択
- **実装方針**: 複数案からの選択理由

### 3. 振り返り・改善
- **AI選択の適切性**: タスクとAIのマッチング評価
- **協調効果**: AI間連携による品質・効率向上
- **コスト効果**: 投入リソースと得られた成果の分析

## 運用ガイド

### 1. 日常的な開発フロー
1. **要件分析**: Claude Code による初期分析
2. **AI選択**: タスク特性に応じたAI選定
3. **協調実装**: zen-mcp-serverを活用した複数AI協働
4. **品質確認**: 自動テスト + 人間による最終チェック
5. **記録・振り返り**: 作業サマリーでの詳細記録

### 2. 緊急時・問題発生時
- **AI判断の疑問**: 人間による即座の介入・確認
- **セキュリティ懸念**: 即座に作業停止、専門家に相談
- **品質問題**: 複数AIによる再検証、根本原因分析

### 3. 定期的な見直し
- **月次**: AI使用状況、コスト、効果の評価
- **四半期**: ルール・プロセスの見直し、改善
- **年次**: AI技術進歩に応じたルール大幅更新

## zen-mcp-server 運用ガイドライン

### 1. 基本的な使用方法

#### コマンド形式
```bash
# 基本形式
/ツール名 "プロンプト"

# モデル指定
/ツール名 "model: gemini-pro
プロンプト"

# 会話継続
/ツール名 "continuation_id: 前回のID
追加の指示"
```

#### 主要ツールと推奨用途
- `/chat` - 一般的な質問、ブレインストーミング（auto）
- `/thinkdeep` - 複雑な問題の深い分析（gemini-pro, o3）
- `/consensus` - 設計判断の合意形成（複数モデル）
- `/codereview` - 包括的なコードレビュー（gemini-pro）
- `/debug` - バグの根本原因分析（o3）
- `/secaudit` - セキュリティ監査（gemini-pro）
- `/analyze` - アーキテクチャ分析（gemini-pro）
- `/refactor` - リファクタリング提案（auto）
- `/testgen` - テストコード生成（o3）
- `/precommit` - コミット前チェック（flash）

### 2. 効果的な活用パターン

#### 段階的アプローチ
```bash
# 1. 高速な初期チェック
/codereview "model: flash
基本的なチェックを実行"

# 2. 問題があれば深掘り
/thinkdeep "model: gemini-pro
thinking_mode: high
[具体的な問題の分析]"

# 3. 複数視点での検証
/consensus "models: [
  {model: 'gemini-pro', stance: 'for'},
  {model: 'o3', stance: 'against'}
]
提案された解決策の評価"
```

#### 会話の継続性活用
```bash
# AI間で情報を引き継ぎながら問題解決
/analyze → /debug → /refactor → /testgen
（continuation_idで接続）
```

## 定型ワークフローテンプレート

よく使用されるAIツール組み合わせのテンプレート集：

### A. 新機能開発フロー
```bash
# 1. 設計合意形成（必須）
/consensus "新機能: [機能名]
要件: [要件詳細]
技術検討事項: [検討ポイント]"

# 2. セキュリティ事前チェック
/secaudit "security_scope: [対象範囲]
新機能のセキュリティリスク評価"

# 3. 実装完了後のレビュー
/codereview "relevant_files: [実装ファイル一覧]
model: gemini-pro"

# 4. テスト生成
/testgen "対象: [実装コード]
model: o3"
```

### B. バグ修正フロー
```bash
# 1. 根本原因分析（必須）
/debug "症状: [バグの症状]
エラーメッセージ: [エラー内容]
関連ファイル: [該当ファイル]
model: o3"

# 2. 修正案検討
/consensus "バグ修正案の比較検討
原因: [分析結果]
修正案A: [案1]
修正案B: [案2]"

# 3. 修正後の影響分析
/analyze "修正内容: [修正詳細]
影響範囲の分析"
```

### C. リファクタリングフロー
```bash
# 1. 現状分析
/analyze "対象: [リファクタリング対象]
現在の問題点と改善点を分析"

# 2. リファクタリング提案
/refactor "refactor_type: decompose
対象ファイル: [ファイルパス]
model: gemini-pro"

# 3. 複数AI による検証
/consensus "リファクタリング案の評価
提案内容: [リファクタリング案]
models: [
  {model: 'gemini-pro', stance: 'for'},
  {model: 'o3', stance: 'neutral'}
]"
```

### D. コミット前チェックフロー
```bash
# 1. 事前チェック（必須）
/precommit "変更内容の包括的チェック
model: flash"

# 2. 問題発見時の詳細分析
/codereview "model: gemini-pro
precommitで発見された問題の詳細分析"

# 3. セキュリティ最終確認
/secaudit "audit_focus: owasp
コミット対象の最終セキュリティチェック"
```

### 3. コスト最適化

#### モデル選択の指針
- **Flash（低コスト）**: スタイルチェック、簡単な確認
- **O3-mini（中コスト）**: バランスの取れた分析
- **Gemini Pro / O3（高コスト）**: 複雑な問題、重要な判断

#### 効率的な使用
- 定型タスクは低コストモデル
- 重要な判断のみ高性能モデル
- バッチ処理で複数ファイルを効率的に処理

### 4. 品質保証プロセス

#### AI協調レビューフロー
1. **Flash**で基本チェック（構文、スタイル）
2. **Gemini Pro**でアーキテクチャレビュー
3. **O3**でロジック検証
4. **人間**による最終確認

#### 継続的な品質向上
- レビュー結果の蓄積と分析
- よくある問題パターンの特定
- AIへのフィードバックループ構築

### 5. トラブルシューティング

#### ログ確認
```bash
# リアルタイムログ監視
tail -f /home/bohemian1506/ai-development/zen-mcp-server/logs/mcp_server.log

# エラー確認
grep "ERROR" logs/mcp_server.log | tail -20

# ツール実行履歴
tail -f logs/mcp_activity.log
```

#### 一般的な問題と対処
- **タイムアウト**: thinking_modeを下げる
- **コンテキスト超過**: 会話を分割
- **APIエラー**: キーの残高確認、レート制限確認

### 6. セキュリティとコンプライアンス

#### APIキー管理
- 環境変数での管理徹底
- 定期的なキーローテーション
- アクセスログの監視

#### データ保護
- センシティブ情報のマスキング
- ログの適切な管理
- AIへの入力内容の事前確認

## Claude Code プロアクティブ提案システム

### 自動提案の実装方針

Claude Codeの動作に以下のプロアクティブ提案機能を組み込む：

#### 1. コンテキスト検知による自動提案
```markdown
**実装箇所**: CLAUDE.md の important-instruction-reminders

**検知パターン**:
- "新機能" "実装" → `/consensus`提案
- "バグ" "エラー" → `/debug`提案  
- "コミット" "push" → `/precommit`提案
- "セキュリティ" "認証" → `/secaudit`提案
- "リファクタリング" → `/refactor`提案
```

#### 2. タスク段階での自動判断
```markdown
**判断ロジック**:
- ファイル作成・編集後 → `/codereview`提案
- 複雑な実装完了後 → `/testgen`提案
- アーキテクチャ変更後 → `/analyze`提案
- 多数のファイル変更 → `/precommit`強制実行
```

#### 3. ユーザー承認プロセス
```markdown
**提案形式**:
「この[タスク内容]では複数AIによる[分析種別]が効果的です。
/[ツール名]で[具体的な内容]を実行しますか？

[y/n]で選択してください。」

**自動実行**（必須条件のみ）:
- コミット前チェック
- セキュリティ関連コード
- 新機能設計時
```

### 実装の制約と考慮事項

#### 技術的制約
- Claude Codeの内部動作への直接的な変更は不可
- CLAUDE.mdとプロンプト設計による間接的な実装
- MCPサーバー側での制御は限定的

#### コスト管理
- 自動提案は低コストモデル（Flash）を優先
- 重要なタスクのみ高性能モデル使用
- ユーザー承認による実行制御

#### ユーザー体験
- 過度な提案による作業中断を回避
- 適切なタイミングでの提案表示
- 簡単な承諾/拒否の仕組み

## 関連ドキュメント
- **[開発ルール](../setup/development-rules.md)**: 基本的なコーディング規約
- **[GitHub環境構築](../workflows/github-setup.md)**: GitHub CLI セットアップ
- **[GitHubワークフロー](../workflows/github-workflow.md)**: Issue、PR作成・管理方法
- **[Claude Code自動ワークフロー](../workflows/claude-code-workflow.md)**: Claude Code特化運用ルール
- **[セットアップガイド](../setup/setup.md)**: 環境構築手順
- **[zen-mcp-setup.md](zen-mcp-setup.md)**: zen-mcp-server詳細セットアップガイド
- **[zen-mcp-workflow.md](zen-mcp-workflow.md)**: zen-mcp-server実践的ワークフロー
- **zen-mcp-server/CLAUDE.md**: AI協調開発の技術詳細
- **zen-mcp-server/docs/ai-collaboration.md**: AI間会話機能説明